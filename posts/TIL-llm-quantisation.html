<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ðŸ’¡ TIL: Understanding GGUF Model Quantisation - Just-in-Time Learning</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <header>
    <div class="container">
      <h1><a href="/">Just-in-Time Learning</a></h1>
    </div>
  </header>

  <main class="post-container">
    <article class="post">
      <header class="post-header">
        <h1>ðŸ’¡ TIL: Understanding GGUF Model Quantisation</h1>
        <span class="post-date">December 7, 2024</span>
        <div class="post-tags">
          <span class="post-tag">ai</span><span class="post-tag">llm</span><span class="post-tag">energy-reduction</span><span class="post-tag">performance</span><span class="post-tag">quantisation</span>
        </div>
      </header>
      
      <div class="post-content">
        <p><strong>TL;DR:</strong> GGUF quantisation converts LLM weights from 16-bit to lower precision formats (2-bit to 6-bit) to run large models on consumer hardware. Each format offers different tradeoffs between size, speed, and quality, with Q4_K_S (4-bit) representing the sweet spot for most usersâ€”providing 3.7x size reduction while maintaining good quality. Mixed precision strategies (_S/_M/_L variants) further optimize performance by targeting attention and feed-forward layers with higher precision bits.</p>
<!--more-->

<h2 id="introduction">Introduction</h2>
<p>When experimenting with larger language models (12B, 30B, 70B etc.), choosing the right quantisation format becomes crucial for striking a good balance i.e. running them on consumer hardware while maintaining reasonably good performance. I wrote this guide after spending time looking up different GGUF quantisation types to optimise model selection for my machine&#39;s constraints. This guide explains quantisation methods and their practical tradeoffs to help the reader select the optimal format for their setup.\ The quantisation formats discussed here are implemented in popular frameworks like <a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a>. Q4_K_S is typically the default format due to its good balance of size, speed, and quality, while Q2_K and Q3_K variants are offered for more constrained systems.</p>
<h2 id="what-is-quantisation">What is Quantisation?</h2>
<p>Quantisation converts model weights from 16-bit floating point (F16) to lower precision formats using fixed-size blocks. Each block contains multiple weights that share scaling parameters.\ Perplexity is the key metric used to measure model quality after quantisation. It indicates how well the model predicts text, the lower the perplexity the better the predictions. For example, a change from 5.91 to 6.78 perplexity represents a noticeable but often acceptable drop in prediction quality. A model with perplexity 6.78 is slightly less certain about its predictions than one with perplexity 5.91.</p>
<h2 id="basic-quantisation-types-and-k-quantisation">Basic Quantisation Types and K-Quantisation</h2>
<p>K-quantisation is a way to make AI models smaller using two methods to store weights (the model&#39;s numbers):</p>
<ol>
<li>Type-0 (simpler): reconstructs weight as <code>weight = scale Ã— quant</code></li>
<li>Type-1 (more precise): reconstructs weight as
<code>weight = scale Ã— quant + minimum</code></li>
</ol>
<p>The &quot;block minimum&quot; <code>minimum</code> is the smallest value found in a group of weights. By tracking this minimum, we can represent the other values more precisely relative to it, rather than having to represent their full absolute values.</p>
<p>Each format groups weights into &quot;super-blocks&quot; to save space. Specifically:</p>
<p>Q2_K (2-bit):</p>
<ul>
<li>Uses Type-1 formula</li>
<li>Organises weights in groups of 256 (16 blocks Ã— 16 weights)</li>
<li>Uses 4 bits to store both scales and minimums</li>
<li>Takes exactly 2.5625 bits per weight</li>
<li>Result: Shrinks a 13GB model to 2.67GB, but quality drops (perplexity
increases from 5.91 to 6.78)</li>
</ul>
<p>Q3_K (3-bit):</p>
<ul>
<li>Uses Type-0 formula (simpler one)</li>
<li>Same organisation: 16 blocks Ã— 16 weights</li>
<li>Uses 6 bits to store scales</li>
<li>Takes exactly 3.4375 bits per weight</li>
<li>Better quality than Q2_K but bigger file size</li>
</ul>
<p>Q4_K (4-bit):</p>
<ul>
<li>Uses Type-1 formula</li>
<li>Different organisation: 8 blocks Ã— 32 weights = 256 total</li>
<li>Uses 6 bits for both scales and minimums</li>
<li>Takes exactly 4.5 bits per weight</li>
<li>Much better quality, file size around 3.56GB</li>
</ul>
<p>Q5_K (5-bit):</p>
<ul>
<li>Uses Type-1 formula</li>
<li>Same organisation as Q4_K</li>
<li>Also uses 6 bits for scales and minimums</li>
<li>Takes exactly 5.5 bits per weight</li>
<li>Quality getting very close to original</li>
</ul>
<p>Q6_K (6-bit):</p>
<ul>
<li>Uses Type-0 formula</li>
<li>Back to 16 blocks Ã— 16 weights</li>
<li>Uses 8 bits for scales</li>
<li>Takes exactly 6.5625 bits per weight</li>
<li>Almost perfect quality, file size 5.15GB</li>
</ul>
<p>The main tradeoff: Fewer bits means smaller files but lower quality. More bits means better quality but larger files. This lets users choose what works best for their needs.\ When compressing numbers in Type-1 quantisation, each block keeps track of its smallest value (the minimum). When reconstructing the weights, this minimum is added back after multiplication. This helps preserve the range of values more accurately than just using scaling alone.</p>
<p>A simple way to think of this concept is:</p>
<ul>
<li>Type-0 just stretches/shrinks values using a scale</li>
<li>Type-1 first shifts all numbers by subtracting the minimum (making them
smaller), then scales them for storage, and when reconstructing adds the   minimum back</li>
</ul>
<p>This is why Type-1 generally gives better quality results but needs more storage space. It has to keep track of both the scale and minimum for each block.</p>
<h2 id="mixed-precision-strategies">Mixed Precision Strategies</h2>
<p>K-quantisations use different precision levels for different model components. From <a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a> documentation, there are three variants:</p>
<ul>
<li><p>S (Small): Uses single quantisation throughout Example using Q3_K_S:</p>
<blockquote>
<p>All model tensors â†’ Q3_K (3-bit)\   &gt; Result: 2.75GB size, 6.46 perplexity (7B model)</p>
</blockquote>
</li>
<li><p>M (Medium): Strategic mixed precision Example using Q3_K_M:</p>
<blockquote>
<p>attention.wv<a href="In">^1</a>, attention.wo[^2], feed_forward.w2[^3] â†’ Q4_K (4-bit)\   &gt; All other tensors â†’ Q3_K (3-bit)\   &gt; Result: 3.06GB size, 6.15 perplexity (7B model)</p>
</blockquote>
</li>
<li><p>L (Large): Higher precision mix Example using Q3_K_L:</p>
<blockquote>
<p>attention.wv<a href="In">^1</a>, attention.wo[^2], feed_forward.w2[^3] â†’ Q5_K (5-bit)\   &gt; All other tensors â†’ Q3_K (3-bit)\   &gt; Result: 3.35GB size, 6.09 perplexity (7B model)</p>
</blockquote>
</li>
</ul>
<p>These strategies target attention and feed-forward layers with higher precision because they directly impact text processing quality, as demonstrated by the perplexity improvements in benchmarks: Q3_K_S (6.46) â†’ Q3_K_M (6.15) â†’ Q3_K_L (6.09).\ The improvement in perplexity scores demonstrates why mixed precision strategies are effective, though they require more storage space.</p>
<h2 id="performance-comparison-7b-model">Performance Comparison (7B model)</h2>
<pre><code>Format | Size(GB) | Reduction | BPW  | Perplexity | RTX4080  | M2Max
F16    | 13.0     | 1.0x      | 16.0 | 5.91       | 60.0ms   | 116ms
Q2_K   | 2.67     | 4.9x      | 2.56 | 6.78       | 15.5ms   | 56ms
Q3_K_S | 2.75     | 4.7x      | 3.44 | 6.46       | 18.6ms   | 81ms
Q4_K_S | 3.56     | 3.7x      | 4.50 | 6.02       | 15.5ms   | 50ms
Q6_K   | 5.15     | 2.5x      | 6.56 | 5.91       | 18.3ms   | 75ms
</code></pre>
<p>*BPW = Bits Per Weight, Speed in milliseconds per token</p>
<p>Practical Recommendations:</p>
<ul>
<li>Balanced Performance: Q4_K_S</li>
<li>Maximum Compression: Q2_K</li>
<li>Best Quality: Q6_K (matches F16)</li>
<li>Limited RAM: Q2_K or Q3_K</li>
<li>GPU Inference: Q4_K (optimal speed/quality)</li>
</ul>
<p>All data are from recent <a href="https://github.com/ggerganov/llama.cpp/pull/1684">llama.cpp</a> performance benchmarks and <a href="https://github.com/ggerganov/ggml">GGML</a> implementation details.</p>
<h2 id="memory-requirements-for-inference">Memory Requirements for Inference</h2>
<p>When running quantised models, more RAM is required than the model size alone for inference overhead. Memory requirements depend on several factors:</p>
<ul>
<li>Model architecture and size</li>
<li>Batch size for inference</li>
<li>Number of layers loaded at once</li>
<li>Operating system and framework overhead</li>
</ul>
<p>For 7B models (verified from benchmarks):</p>
<pre><code>Format | Model Size | Note
F16    | 13.0GB    | Base format
Q4_K_S | 3.56GB    | Common choice
Q3_K_S | 2.75GB    | Minimum size
Q6_K   | 5.15GB    | Highest quality
</code></pre>
<p>For larger models scale the memory requirements proportionally and ensure additional overhead memory is available for inference. Test with smaller models first to gauge the system&#39;s capabilities.\ Actual RAM/VRAM requirements will be higher than the model size. Consider monitoring memory usage during inference to determine exact requirements for a specific setup.\ Here is an example memory usage scenario for a Q4_K_S 7B model:</p>
<ul>
<li>Model size: 3.56GB</li>
<li>Inference overhead: ~2GB for standard settings</li>
<li>Operating system buffer: ~1GB recommended</li>
<li>Total recommended free memory: ~7GB</li>
</ul>
<p>This explains why a model that&#39;s &quot;3.56GB&quot; might need 6-7GB of free RAM/VRAM to run smoothly. The exact overhead varies based on your settings and system.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Modern quantisation techniques offer multiple ways to run large language models on consumer hardware. Here&#39;s what we need to remember:</p>
<ul>
<li>K-quantisation provides the best balance through super-blocks and mixed</li>
<li>Q4_K_S (4-bit) represents the current sweet spot for most users, offering:</li>
<li>For more constrained setups, Q2_K/Q3_K variants can run larger models with</li>
<li>Higher bits (Q5_K, Q6_K) approach F16 quality but require more memory</li>
<li>The _S/_M/_L variants let the user fine-tune the quality-size tradeoff by
precision strategies   - 3.7x size reduction   - Good perplexity (6.02)   - Excellent inference speed on both GPU and CPU   acceptable quality loss   adjusting precision where it matters most</li>
</ul>
<p>Before downloading a quantised model, check the system&#39;s available RAM and choose a format that leaves enough memory for comfortable operation. For most users with modern GPUs, Q4_K variants will provide the best experience.</p>
<hr>
<pre><code>[llama.cpp](https://github.com/ggerganov/llama.cpp/tree/master/examples/convert-llama2c-to-ggml/convert-llama2c-to-ggml.cpp),
`attention.wv` refers to a tensor that holds the weights for the value
vectors in the self-attention mechanism of the model. This tensor is crucial
for determining how much focus the model places on different parts of the
input when generating responses.
</code></pre>
<p>[^2]: <code>attention.wo</code> refers to the weight matrix used in the output layer of the
    attention mechanism within a transformer model. It plays a crucial role in
    transforming the attention output into the final representation that is used
    for generating predictions.</p>
<p>[^3]: <code>feed_forward.w1</code> projects input to a higher-dimensional space, enabling
    the capture of complex features. <code>feed_forward.w2</code> projects transformed
    input back to the original dimension with a non-linear activation function,
    whereas <code>feed_forward.w3</code> applies an additional transformation to enhance
    the learning of complex patterns. These matrices collectively enable the
    feed-forward network to transform and learn from the input effectively,
    contributing to the overall performance of the transformer model.</p>

      </div>
    </article>
  </main>

  <footer>
    <div class="container">
      <p>Created with <a href="https://github.com/ai-mindset/init.vim">Neovim</a>, using <a href="https://ai-mindset.github.io/dialogue-engineering">AI</a> to help process and curate content âœ¨</p>
    </div>
  </footer>

  <script src="/script.js"></script>
</body>
</html>