<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ðŸ“¦ From Compilation to Containerisation and Back Again - Just-in-Time Learning</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <header>
    <div class="container">
      <h1><a href="/">Just-in-Time Learning</a></h1>
    </div>
  </header>

  <main class="post-container">
    <article class="post">
      <header class="post-header">
        <h1>ðŸ“¦ From Compilation to Containerisation and Back Again</h1>
        <span class="post-date">March 19, 2025</span>
        <div class="post-tags">
          <span class="post-tag">deno</span><span class="post-tag">typescript</span><span class="post-tag">deployment</span><span class="post-tag">cross-platform</span><span class="post-tag">evolution</span><span class="post-tag">toolchain</span><span class="post-tag">best-practices</span><span class="post-tag">code-quality</span>
        </div>
      </header>
      
      <div class="post-content">
        <p><strong>TL;DR:</strong> Programming languages have evolved from compiled executables to
interpreted languages and containerisation, but Deno 2.0 brings deployment full
circle by enabling TypeScript/JavaScript compilation into standalone
binaries-offering simplified cross-platform deployment whilst maintaining
ecosystem richness and enabling single-language development across entire
application stacks.</p>
<!--more-->

<h2 id="introduction">Introduction</h2>
<p>Over the years, I&#39;ve experimented with numerous programming languages and
deployment strategies. Python has been my domain&#39;s lingua franca -with its vast
ecosystem for data science and AI applications. However, its deployment
complexities have consistently been a pain point: managing dependencies,
configuring containers, and setting up build pipelines.<br>This search for a better alternative has led me through statically compiled
languages like Go and Rust; JIT-compiled languages like Julia; and hosted
languages like Clojure and Scala. Yet most failed to provide a good balance
between ecosystem richness and deployment simplicity. Recently, however, Deno
2.0 has emerged as a compelling solution -particularly with its ability to
compile TypeScript (TS) / JavaScript (JS) to standalone executables.</p>
<h2 id="the-circular-evolution-of-programming-languages">The Circular Evolution of Programming Languages</h2>
<p>Programming languages have undergone a fascinating evolution. In the beginning
(the late 1950s and 1960s), languages like Fortran, COBOL, and C were
ahead-of-time compiled -transformed directly into machine code executables that
could run without additional dependencies.<br>As computing evolved, the pendulum swung toward higher-level languages
-interpreted languages like Python and hosted environments like the JVM-
prioritising readability and developer productivity over raw performance. These
languages abstracted away machine-level concerns, allowing developers to focus
on solving business problems.<br>Yet this shift introduced new challenges. Python applications often require
managing complex dependency trees, virtual environments, and platform-specific
configurations. The infamous &quot;<em>works on my machine</em>&quot; problem became so pervasive
that containerisation emerged as a solution.<br>While effective, containerisation introduces its own complexities:
orchestration, image management, and networking configurations. What began as a
solution to simplify deployment has become a complex system requiring
specialised knowledge.</p>
<h2 id="deno-compilation-makes-a-comeback">Deno: Compilation Makes a Comeback</h2>
<p>Deno 2.0 represents a return to first principles. As highlighted in the
<a href="https://youtube.com/watch?v=ZsDqTQs3_G0">Run JavaScript Anywhere</a> video, its
<code>compile</code> command enables developers to transform JS and TS programs into
standalone binaries that run across major platforms -no runtime installation or
dependencies required.</p>
<pre><code class="language-typescript">// sample.ts
import { open } from &quot;https://deno.land/x/open/index.ts&quot;;

// Open a URL in the default browser
await open(&quot;https://example.com&quot;);
</code></pre>
<p>With a simple <code>deno compile sample.ts</code> command, this code becomes a standalone
executable that works on any machine without requiring Deno to be installed.<br>This compilation process isn&#39;t traditional transpilation to machine code -it
embeds your JS and TS code into a specialized Deno runtime binary (denort). Your
script and dependencies are bundled as an EZIP file and injected into the
runtime binary, creating a self-contained executable that can be code-signed for
distribution.</p>
<p>The key benefits include:</p>
<ol>
<li><strong>Cross-platform compatibility</strong> without runtime requirements</li>
<li><strong>Simplified deployment</strong> with single-binary distribution</li>
<li><strong>Bundled assets</strong> for complete portability</li>
<li><strong>Improved startup times</strong> compared to interpreter-based approaches</li>
</ol>
<p>Deno 2.0 enhances these capabilities further with support for npm packages, web
workers, cross-compilation, smaller binary sizes, and code signing with custom
icons - making it viable for complete applications, not just scripts.</p>
<h2 id="the-single-language-advantage">The Single Language Advantage</h2>
<p>Beyond deployment simplicity, using a single language across an entire project
stack creates significant organisational benefits. I&#39;ve experienced first-hand
how using different languages for front-end, back-end, and data science work can
create silos within teams.<br><a href="https://dockyard.com/blog/2024/02/06/5-benefts-amplified-saw-switching-to-elixir">Amplified&#39;s case study</a>
demonstrates this point clearly. After switching from a React/JS front-end and
Phoenix/Elixir back-end to an all-Elixir approach with LiveView, they reported:</p>
<ol>
<li><strong>Halved server costs</strong> through more efficient resource utilisation</li>
<li><strong>Dramatically increased development speed</strong> by eliminating cross-language
silos</li>
<li><strong>Improved team cohesion</strong> with shared tooling and knowledge</li>
<li><strong>Enhanced maintainability</strong> through code reuse</li>
<li><strong>Reduced team size requirements</strong> from 12 developers to just 2</li>
</ol>
<p>TS with Deno provides a similar single language opportunity -allowing teams to
build front-end interfaces, back-end services, and data processing workflows
with the same toolchain. The JS/TS ecosystem is rapidly maturing for AI, ML, and
data science applications, as I noted in my previous article on [Modern Data
Science and AI Engineering with Deno 2.0]({{ site.baseurl }}{% link
_posts/2024-09-05-deno.md %}).<br>One often overlooked benefit is the reduced cognitive load when developers don&#39;t
need to context-switch between different language paradigms, package managers,
testing frameworks, and debugging approaches.</p>
<h2 id="practical-applications">Practical Applications</h2>
<p>Deno&#39;s compilation capabilities shine in several real-world scenarios:</p>
<ol>
<li><strong>CLI Tools</strong>: Creating self-contained executables that &quot;just work&quot; across
platforms without complex installation instructions</li>
<li><strong>Offline Environments</strong>: Deploying to systems without internet access, where
package resolution at runtime isn&#39;t possible</li>
<li><strong>Cross-Platform Applications</strong>: Building desktop applications that leverage
web technologies without requiring a browser runtime</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>We&#39;ve come full circle in programming language evolution -from compiled
languages like Fortran in the 1950s, to interpreted languages for improved
developer experience, to containerisation for managing deployment complexities,
and now back to compilation with Deno[^1].<br>Deno&#39;s approach represents a compelling blend - combining deployment simplicity
with the ecosystem richness of modern TS/JS. For AI engineering, this addresses
many pain points of Python deployment while maintaining access to growing
ecosystem of data science tools.<br>While Elixir offers similar single language benefits, its distribution story
remains a work in progress with projects like
<a href="https://github.com/burrito-elixir/burrito">Burrito</a> showing promise but not yet
fully mature. Until then, Deno stands out as a viable alternative for simplified
deployment without sacrificing ecosystem benefits.<br>The future of deployment may look surprisingly like its past, just with better
languages and tools at our disposal -offering a path toward more cohesive,
efficient software development that reduces complexity without sacrificing
capability.</p>
<hr>
<p>[^1]: Go, Zig, Rust, C/C++ D, Nim, Common Lisp are some prominent examples of
    ahead-of-time compiled languages that -with the exception of Common Lisp-
    excel in systems programming. However, Deno allows a ubiquitous,
    higher-level language like JS and its superset TS to join the club of
    languages that can easily package code to a cross-platform single binary.</p>

      </div>
    </article>
  </main>

  <footer>
    <div class="container">
      <p>Created with <a href="https://github.com/ai-mindset/init.vim">Neovim</a>, using <a href="https://ai-mindset.github.io/dialogue-engineering">AI</a> to help process and curate content âœ¨</p>
    </div>
  </footer>

  <script src="/script.js"></script>
</body>
</html>